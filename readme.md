This is a redundant traversal bugs detection tool. The idea is from the paper
[Static Detection of Asymptotic Performance Bugs in Collection Traversals](https://www.cs.utexas.edu/~lin/papers/pldi15.pdf).
Code is built on [Soot](https://github.com/Sable/soot) and [VASCO](https://github.com/rohanpadhye/vasco).

Build
=====
```
./gradlew assemble
./gradlew testClasses
```

Run
===
Since the analysis is written in Java 8
and Soot can only analyze runtime library up to Java 7, additional classpath
for the runtime (jce.jar and rt.jar) should be passed to Soot. For example:

```
java -cp ./build/classes/main PerformanceAnalysis -cp build/classes/test:/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/jre/lib/rt.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/jre/lib/jce.jar Example
```

For code like this,
```Java
public static void testCase1() {
    List<Integer> int_list = new ArrayList<>();

    for (int i : int_list) {
        Integer max = computeMaxIdx(int_list);
    }
}

public static void testCase2() {
    // Cannot reason about recursive data structure
    List<Integer> int_list = new LinkedList<>();

    for (int i : int_list) {
        Integer max = computeMaxIdx(int_list);
    }
}

public static void testCase3() {
    ArrayList<Integer> int_list = new ArrayList<>();

    for (int i : int_list) {
        Integer max = computeMaxIdx(int_list);
        // Write int_list so that the traversal is not redundant
        int_list.add(1);
    }
}

private static Integer computeMaxIdx(List<Integer> c) {
    Integer max = 0;

    for (int i = 0; i < c.size(); i++) {
        if (c.get(i) > max) {
            max = i;
            break;
        }
    }

    return max;
}
```
It will give a warning on `testCase1`
```
<Example: void testCase1()> has possible performance bug.
```


Limitation
==========
- Native methods and fields are not simulated. Traversal footprints are generated by inference only.
(Implementation in that paper uses annotation for native methods)
- There is only alias analysis for local variables in backward order. It is unable to reason alias
relationship between object fields, like whether `r0.b.c` and `r1.c` alias. This produces more
false positives than the implementation in paper.


Thoughts
========
If we can get precise context-sensitive point-to information, it seems this analysis can be done in
forward flow, using heap objects instead of variable names in the footprint set. This avoids
renaming variables in the footprint set at call sites and probably enables the detection of traversal
on recursive data structure.

